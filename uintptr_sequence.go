// Code generated by cmd/generate. DO NOT EDIT.

package timeseq

import (
	"errors"
	"sort"
	"time"
)

// UintptrItem is item of UintptrSequence
type UintptrItem struct {
	Time  time.Time
	Value uintptr
}

// UintptrSequence is the implement of Sequence for uintptr
type UintptrSequence []UintptrItem

// Len implements Sequence.Len
func (s UintptrSequence) Len() int {
	return len(s)
}

// Swap implements Sequence.Swap
func (s UintptrSequence) Swap(i, j int) {
	s[i], s[j] = s[j], s[i]
}

// Time implements Sequence.Time
func (s UintptrSequence) Time(i int) time.Time {
	return s[i].Time
}

// Slice implements Sequence.Slice
func (s UintptrSequence) Slice(i, j int) Sequence {
	return s[i:j]
}

// Sort will sort sequence by time
func (s UintptrSequence) Sort() {
	Sort(s)
}

// Range return sub sequence, would sort sequence if it is not sorted
func (s UintptrSequence) Range(afterOrEqual, beforeOrEqual *time.Time) UintptrSequence {
	if !sort.IsSorted(sortableSequence{s}) {
		s.Sort()
	}
	return Range(s, afterOrEqual, beforeOrEqual).(UintptrSequence)
}

// First return the first item or nil if not exists, would sort sequence if it is not sorted
func (s UintptrSequence) First(afterOrEqual *time.Time) *UintptrItem {
	if !sort.IsSorted(sortableSequence{s}) {
		s.Sort()
	}
	i := First(s, afterOrEqual)
	if i < 0 {
		return nil
	}
	ret := s[i]
	return &ret
}

// Last return the last item or nil if not exists, would sort sequence if it is not sorted
func (s UintptrSequence) Last(beforeOrEqual *time.Time) *UintptrItem {
	if !sort.IsSorted(sortableSequence{s}) {
		s.Sort()
	}
	i := Last(s, beforeOrEqual)
	if i < 0 {
		return nil
	}
	ret := s[i]
	return &ret
}

// Max return the first item which has the max value, or nil if not exists
func (s UintptrSequence) Max() *UintptrItem {
	var max *UintptrItem
	for i, v := range s {
		if max == nil {
			max = &s[i]
		} else if v.Value > max.Value {
			max = &s[i]
		}
	}
	if max != nil {
		value := *max
		max = &value
	}
	return max
}

// Min return the first item which has the min value, or nil if not exists
func (s UintptrSequence) Min() *UintptrItem {
	var min *UintptrItem
	for i, v := range s {
		if min == nil {
			min = &s[i]
		} else if v.Value < min.Value {
			min = &s[i]
		}
	}
	if min != nil {
		value := *min
		min = &value
	}
	return min
}

// Sum return the value's sum
func (s UintptrSequence) Sum() uintptr {
	var sum uintptr
	for _, v := range s {
		sum += v.Value
	}
	return sum
}

// Average return the value's average
func (s UintptrSequence) Average() uintptr {
	if len(s) == 0 {
		return 0
	}

	return uintptr(float64(s.Sum()) / float64(len(s)))
}

// Percentile return (pct)th percentile
func (s UintptrSequence) Percentile(pct float64) uintptr {
	if pct > 1 || pct < 0 {
		panic(errors.New("percentile must be [0, 1]"))
	}

	var values []uintptr
	for _, v := range s {
		values = append(values, v.Value)
	}
	sort.Slice(values, func(i, j int) bool {
		return values[i] < values[j]
	})

	if len(values) == 0 {
		return 0
	}

	index := int(float64(len(s))*pct - 1)
	if index < 0 {
		index = 0
	}

	return values[index]
}
